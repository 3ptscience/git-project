#!/bin/bash

CWD=$(pwd)

# --- Define Functions ---
finish (){
    cd $CWD
    exit $1 
}

# Switch to root directory and ensure
# .gitproj exists
root=$(git rev-parse --show-toplevel)

cd $root

if [ ! -s .gitproj ]; then
    echo ".gitproj file missing. Refer to the git-project readme"
    finish 0
fi
# Location of .gitproj
GITPROJ=$(pwd)/.gitproj 
# name of repository
BASE=${PWD##*/} 
# operation mode
MODE="USAGE"

darwin=false;
case "`uname`" in
  Darwin*) darwin=true ;;
esac

if $darwin; then
  sedi="/usr/bin/sed -i .bak"
else
  sedi="sed -i"
fi

# set MODE
case $1 in
    init)
        MODE="INIT"
        ;;
    save)
        MODE="SAVE"
        ;;
    load)
        MODE="LOAD"
        ;;
    status)
        MODE="STATUS"
        ;;
    *)
        ;;
esac

shift

# operation styles
FORCE=false
USECOMMIT=false
AUTOCLONE=false
AUTOMERGE=false

# set flags
while [[ $# -ge 1 ]];
do
    key="$1"
    case $key in
        -f|--force)
            FORCE=true
            ;;
        -c|--commit)
            USECOMMIT=true
            ;;
        -a|--autoclone)
            AUTOCLONE=true
            ;;
        -m|--automerge)
            AUTOMERGE=true
            ;;
        -r|--repos)
            echo "Repos not yet implemented"
            ;;
        *)
            ;;
    esac
    shift
done

subrepos=`cat $GITPROJ | sed -n -e '/^repos:$/,/^states:$/p' | grep -v ':$'`

if [ $MODE == INIT ]; then

    while read -r line || [[ -n "$line" ]]; do
        repo=`echo $line | awk '{print $1}'`;
        url=`echo $line | awk '{print $2}'`;

        echo "cloning repo..."
        echo "$line"

        cd $repo;
        if [ $? -ne 0 ]; then
            echo "Cloning $repo..."
            git clone $url $repo
                
            if [ $? -ne 0 ]; then
                echo "Error cloning repo $repo"
                finish 1
            fi

            echo "$repo" >> .gitignore
        fi

    done <<< "$subrepos"

elif [ $MODE == STATUS ] ; then

    columnExists=false
    hash column 2>/dev/null
    if [ $? -eq 0 ] ; then
        columnExists=true
    fi

    output=""
    while read -r line || [[ -n "$line" ]]; do
        repo=`echo $line | awk '{print $1}'`;

        cd $repo;
        if [ $? -ne 0 ]; then
            output="$output\n$repo >>>>>DOES NOT EXIST. CLONE FIRST<<<<<"
        else
            branch=$(git branch | grep "*" | awk '{ print $2 }')
            commit=$(git log | head -n1 | awk '{print $2}')
            output="$output\n$repo $branch $commit"
        fi
        cd - >> /dev/null
    done <<< "$subrepos"

    echo ""
    echo "-----CURRENT STATE (to be written on 'git project save')-----"
    echo ""
    if $columnExists ; then
        echo -e "$output" | column -t
    else
        echo -e "$output" 
    fi

    echo ""

    echo "-----SAVED STATE (currently in .gitproj)-----"
    echo ""

    if $columnExists ; then
        sed -n -e '/^states:$/,$p' $GITPROJ | grep -v ':$' | column -t
    else
        sed -n -e '/^states:$/,$p' $GITPROJ | grep -v ':$'
    fi
    echo ""

elif [ $MODE == SAVE ] ; then

    if [ `git status | grep "working directory clean" | wc -l` -ne 1 ]; then
        echo "You have uncommitted changes. Please commit these before proceeding"
        finish 1
    fi

    if ! $FORCE && [ -s $GITPROJ ]; then
        read -n 1 -p "Saved State already exists. Overwrite? [y/n/q]" overwrite < /dev/tty
        if [ $overwrite != y ]; then
            finish 1;
        fi
    fi

    echo "Saving repo state:"
    echo $GITPROJ

    $sedi -e '/^states:$/,$d' $GITPROJ

    if [ -s .gitproj.bak ]; then
        rm .gitproj.bak
    fi

    echo "states:" >> $GITPROJ

    while read -r line || [[ -n "$line" ]]; do
        repo=`echo $line | awk '{print $1}'`
        cd $repo;
        branch=`git branch | grep "*" | awk '{ print $2 }'`;
        commit=`git log | head -n1 | awk '{print $2}'`;
        echo "    $repo $branch $commit" >> $GITPROJ
        cd - >> /dev/null;
    done <<< "$subrepos"

#    column -t $GITPROJ

    if [ `git status | grep "working directory clean" | wc -l` -eq 1 ]; then
        echo "No changes to be saved"
        exit 0
    fi

    git add $GITPROJ
    if [ $? -ne 0 ]; then
        echo "Error"
        finish 1
    fi
    git commit -m "Save Sub-Repository State"
    if [ $? -ne 0 ]; then
        echo "Error committing $GITPROJ"
        finish 1
    fi

elif [ $MODE == LOAD ]; then

    if [ ! -s $GITPROJ ]; then
        echo "No Saved State.";
        exit -1;
    fi

    echo "***$BASE***"

    branch=`git branch | grep "*" | awk '{print $2}'`;

    git fetch origin --prune

    if [ `git status | grep "behind" | wc -l` -ne 0 ]; then

        if $AUTOMERGE || $FORCE; then 
            merge=y
        else 
            read -n 1 -p "There are new commits in $BASE:$branch. Do you want to merge them in? [y/n/q] " merge < /dev/tty
        fi

        if [ $merge == y ]; then
            git merge origin/$branch
        elif [ $merge == q ]; then
            finish 1
        fi
    else
        echo "Your branch is up-to-date with 'origin/$branch'."
    fi

    echo ""

    repoStates=`sed -n -e '/^states:$/,$p' $GITPROJ | grep -v ':$'`

    while IFS='' read -r line || [[ -n "$line" ]]; do
        repo=`echo $line | awk '{print $1}'`;
        branch=`echo $line | awk '{print $2}'`;
        commit=`echo $line | awk '{print $3}'`;

        cd $repo;
        if [ $? -ne 0 ]; then
            if $AUTOCLONE || $FORCE; then 
                clone=y
            else 
                read -n 1 -p "Unknown sub-repo $repo, do you want to try to clone it? [y/n/q] "  clone </dev/tty;
            fi
            if [ $clone == y ]; then
                repoUrl=$(echo "$subrepos" | grep "\s$repo\s" | awk '{print $2}')
                echo "looking for $repo in "
                echo "$subrepos"
                echo "found $repoUrl"
                git clone $repoUrl $repo -b $branch
                if [ $? -ne 0 ]; then
                    echo "Error cloning repo $sub"
                    finish 1
                fi
            elif [ $clone == q ]; then
                finish 1
            else
                continue
            fi

            cd $repo;
        fi

        echo "***$repo***"
        if $USECOMMIT; then
            git checkout $commit
        else
            git checkout $branch
            git fetch origin --prune
            if [ `git status | grep "behind" | wc -l` -ne 0 ]; then

                if $AUTOMERGE || $FORCE; then 
                    merge=y
                else 
                    read -n 1 -p "There are new commits on $repo:$branch, do you want to merge them in? [y/n/q] "  merge </dev/tty
                fi

                if [ $merge == y ]; then
                    git merge origin/$branch
                elif [ $merge == q ]; then
                    finish 1
                fi
            fi
        fi
        if [ $? -ne 0 ]; then
            echo "Encountered an error switching branches. Please fix and re-try"
            finish 1;
        fi
        echo ""
        cd - >> /dev/null;
    done <<< "$repoStates" 

elif [ $MODE == USAGE ]; then
    echo "Usage: git project <init|save|load> [--repos <repos>]"
    finish 1
fi

finish 0
